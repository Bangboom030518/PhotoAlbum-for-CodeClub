<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../bower_components/polymer/polymer.html">
<script>
    /**
     * `SingleBehaviors` 
     *
     * @polymerBehavior SingleBehaviors
     **/
    class SingleBehaviors extends Polymer.Element {
        constructor() {
            super();
        }

        static get is() {
            return 'single-behaviors'
        }

        static get properties() {
            return {
                xmlData: {
                    type: Object,
                    notify: true,
                },
                selectedItem: {
                    type: String
                },
                selectedIndex: {
                    type: Number,
                    value: -1,
                    notify: true,
                },
                once: {
                    type: Boolean,
                }
            };
        }
        /**
         * Selects the previous item.
         *
         * @method xmlDataPrevious
         */
        xmlDataPrevious(index) {
            var length = this.xmlData.items.length;
            return ((this.validateIndex(index) - 1 + length) % length);
        };

        /**
         * Selects the next item.
         *
         * @method xmlDataNext
         */
        xmlDataNext(index) {
            return ((this.validateIndex(index) + 1) % this.xmlData.items.length);
        };
        /**
         * Ensure that the index passed in is a number and is in the range for the data loaded
         *
         * @method validateIndex
         */
        validateIndex(indexToValidate) {
            var index = parseInt(indexToValidate);
            if (index < 0) {
                // Index not valid so check route data to find correct index
                index = this.getXmlDataIndex(this.selectedItem);
                if (index < 0) {
                    // Still not found
                    index = this.getXmlDataIndex(this.selectedIndex);
                }
            }
            // Keep true
            if ((index > this.xmlData.items.length) || (index < 0)) {
                index = 0; // Zero will have to do
            }
            return index;
        };

        getXmlDataIndex(link) {
            return this.xmlData.items.map(function (item) {
                return item.link;
            }).indexOf(link);
        };

        getUrlIndex(item, xmlData) {
            if (this.once == false && item.link == xmlData.items[0].link) {
                this.once = true;
                if (this.shadowRoot) {
                    this.shadowRoot.querySelector('paper-button').focus();
                } else {
                    // this.querySelector('paper-button').focus();
                }
            }
            return this.getUrl(item);
        };

        getUrl(item) {
            return item.link;
        };

        getTagImage(item, xmlData) {
            var image;
            if (xmlData !== null && xmlData.ContainsPhotos === 'true' && item.ContainsPhotos === 'true') {
                image = 'M/' + item.link;
            } else if (item.tagImage !== undefined) {
                image = item.tagImage;
            } else {
                image = 'M/' + item.link;
            }
            return '../gallery/' + image + '.jpg';
        };

        getLargeImage(item, xmlData) {
            var image;
            if (xmlData && xmlData.ContainsPhotos === 'true' && item.ContainsPhotos === 'true') {
                image = 'X/' + item.link;
            } else if (item.tagImage !== undefined) {
                image = item.tagImage;
            } else {
                image = 'X/' + item.link;
            }
            return '../gallery/' + image + '.jpg';
        };

        getXmlDataItem(index) {
            return this.xmlData.items[index];
        };

        _selectItem(e) {
            var path = e.currentTarget.attributes.url.value;
            this._changePath(path);
        };

        _changePath(path) {
            this.dispatchEvent(new CustomEvent('slide', {
                bubbles: true,
                composed: true,
                detail: path
            }));
        };
    }
    customElements.define(SingleBehaviors.is, SingleBehaviors);
</script>